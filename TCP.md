
#### TCP和UDP区别

- UDP无连接，TCP需要进行三次握手建立连接
- UDP支持一对一、一对多和多对多通信，TCP仅支持一对一
- UDP对应用层交付的报文直接打包传输，TCP面向字节流，数据先被放入缓冲区，等待时机合适再以字节流的形式发送
- UDP不可靠，报文可能丢失，TCP是可靠传输，支持流量控制和拥塞控制
- UDP首部仅8个字节，TCP首部20~60字节

#### IP首部

固定20字节，其余可选字段长度可变。

- 4bit版本，4bit首部长度，1字节区分服务，2字节总长度
- 2字节标识，3bit标识位，13bit片偏移
- 1字节生存时间，1字节协议，2字节首部校验和
- 4字节源IP地址
- 4字节目的IP地址
- 可选+填充

#### UDP首部

固定8字节，源端口号、目的端口号、报文长度、校验和，分别2个字节。

#### TCP首部

固定20字节，其余可选长度，

- 2字节源端口号，2字节目的端口号
- 4字节序号
- 4字节确认好
- 4bit数据偏移（首部长度），6bit保留字段，6个标识位，URG紧急指针标识，ACK确认字段标识，PSH接收方立即将数据交给应用层，RST重置连接只有发生错误时，SYN用于建立连接三次握手，FIN用于断开连接四次挥手，2字节窗口大小用于流量控制
- 2字节校验和，2字节紧急指针
- 可选+填充

#### 三次握手

首先分为A客户端，B服务端

- B必须处于LISTEN状态，等待客户端请求
- A向B发送SYN请求报文，选择一个初始序号x，状态变为SYN-SENT
- B收到A的SYN请求，服务端响应，回复一个SYNACK，确认号为x+1，选择一个初始序号y，状态变为SYN-RCVD，并为该请求分配资源（TCP会缓存客户端数据的最新时间戳，如果后续请求小于该时间戳会直接丢弃）
- A收到SYNACK报文后，向B发送ACK，序号为x+1，确认号为y+1，状态变为ESTABLISHED
- B收到A的ACK后，连接确立，状态变为ESTABLISHED

> 为什么不是四次握手
> 
> 第二次握手，由于正在建立连接，SYN和ACK之间不需要处理其他资源，将SYN和ACK合并发送，从而不需要四次握手

> 为什么不是二次握手
>
> 三次握手是双方互相确认双方是否具有收发能力，第三次握手之前，服务端不能确定客户端是否具有接受能力。
>
> 如果两次握手，第二次服务端SYNACK丢失，服务端不能感知这次丢失，会认为连接已建立，而客户端未收到确认，超时后会重新发送SYN请求建立连接，此时服务端可能会打开两个连接。
>
> 如果客户端请求再网络中滞留，重发请求建立连接后，第一次请求才到达服务端，此请求已失效，服务端可能会错误建立已失效连接。而第三次握手，客户端不会对失效请求的响应回复，从而避免了失效请求建立连接。
>
> 两次握手对于累计确认是不完整的，服务端不会收到SYNACK请求的确认号，无法更新滑动窗口。

> SYN泛洪攻击
>
> 如果服务端响应SYNACK，客户端却不回应，此时TCP处于半连接状态，服务端仍然给客户端分配了资源，如果出现成千上万这种连接请求，服务端资源将被耗尽。

#### 四次挥手

A、B双方处于连接中，A为主动关闭方

- A发送一个FIN报文，A进入FIN-WAIT1状态
- B收到A的FIN后，返回一个ACK，B进入CLOSE-WAIT，连接半关闭
- A收到B的ACK后，进入FIN-WAIT2状态，等待B的FIN
- B在处理完A剩余的报文后，发送FIN报文，进入LAST-ACK
- A在收到B的FIN后，给B返回一个ACK，进入TIME-WAIT，等待2MSL（报文最长往返时间）后关闭连接
- B收到A的ACK关闭连接

> 为什么四次挥手
>
> 由于服务端进入CLOSE-WAIT，是为了让服务端发送完还未发送完毕的数据，传送完毕后才能发送FIN报文。CLOSE-WAIT一般很短，如果大量出现CLOSE-WAIT状态，代表连接出现了问题。

> 为什么TIME-WAIT
>
> 等待2个MSL，是为了确认最后一个ACK能够到达，如果ACK丢失，对方就会重新发送FIN，如果此时连接已关闭，对方就会收到RST表示发生错误，因此需要等待一段时间以处理重发的FIN。
>
> 为了让该连接的所有报文都从网络中消失，防止下一个连接出现旧的报文信息。

#### TCP可靠传输

TCP需要解决数据包在网络中遇到的损坏、乱序、冗余、丢包问题。TCP通过差错检验（校验和）检测数据是否损坏，通过停止等待协议和滑动窗口解决乱序问题，通过累计确认和超时重传解决丢包问题。

- 校验和：发送方计算校验和并放入TCP报文首部，接收方收到数据后计算校验和并与发送方的对比。

- 确认应答+序列号：接收方收到发送方的报文后，会进行确认应答，回复ACK表示想要收到的下一条报文序号，确认应答采用累积确认，如果收到乱序报文，接收方会进行缓存，并回复窗口内最左连续已确认报文的ACK，发送发收到该ACK后，会发送该缺失报文。

- 超时重传；发送方在发送数据后会启动定时器，等待接收方的ACK，如果该时间内未收到ACK就会进行重传，最大超时时间根据计算估计得到，根据RTT报文往返时间的指数加权平均计算平均往返时间，TCP报文超时时间RTO应略大于平均往返时间。超时重传后，每次超时时间加倍。

- 快速重传：发现3个冗余ACK，立即进行重传。

- 滑动窗口：发送发通过流水线形式一次性发送多个分组，滑动窗口用来缓存数据包，记录确认信息。
  - 发送方缓存已发送未确认，接收方缓存已接受分组。发送发窗口左方为连续发送已确认的分组，窗口第一个是发送未确认，其余为发送未确认和发送已确认分组，当窗口第一个分组变为已确认时，窗口左端向右滑动至第一个未确认分组为止。
  - 发送方根据TCP报文首部的窗口字段调整窗口大小，实现流量控制，如果发送报文不在窗口内则缓存等待窗口滑动
  - 接收方窗口第一个为按序的未接收分组，接收方缓存已接收到的分组，当第一个分组接收到时，窗口左端右移至第一个未接收分组，将按序缓存的分组交给上层，当接收端接收到报文时，标记窗口内该分组已接收，返回一个ACK为按序收到的最新的一个分组

#### 流量控制

为了消除发送方使接收方缓存溢出的可能性，使发送方的速度与接收方的速度匹配。

接收方缓存中，有读索引和写索引，TCP报文首部接收窗口的值=接收方缓存大小-（写索引-读索引），接收方把该值放入窗口字段发送给发送方。

如果接收窗口为0，且接收方不会主动向发送方发送数据，此时发送方无法得知接收方缓存变化，发送放会发送只有1个字节的探测报文，探测接收方返回的窗口大小。

#### 拥塞控制

拥塞控制是发送方由于网络拥塞，抑制发送方速度，调整拥塞窗口cwnd。实际的发送端滑动窗口为拥塞窗口和接收窗口的最小值。

- 分组重传作为网络拥塞的征兆，一个丢失的报文分组意味着拥塞，此时会降低发送方速率
- 一个确认报文表示可以增加发送速率
- 发送方超时丢包或者产生3个冗余确认，都可认为拥塞

拥塞算法包括，慢启动、拥塞避免、快速恢复。

- 慢启动
  - 建立连接时，cwnd以一个MSS，每次收到ACK时，cwnd加倍直至慢启动阈值，此时进入拥塞避免
  - 如果发生超时丢包，慢启动阈值设置为当前cwnd/2，cwnd至为1个MSS重新进行慢启动
  - 如果发生3次冗余ACK，执行快速重传立即重传下一个报文，并进入快速恢复
- 拥塞避免
  - 每经历一次报文往返时间RTT，cwnd增加一个MSS，每收到一个ACK，cwnd增加MSS/cwnd个MSS
  - 当发生超时丢包，慢启动阈值变为当前cwnd/2，cwnd至为1个MSS重新进行慢启动
  - 如果发生3次冗余ACK，进行快速重传立即重传下一个报文，进入快速恢复
 - 快速恢复
  - 每收到一个冗余ACK，cwnd增加一个MSS
  - 收到非冗余的ACK时，进入拥塞避免
  - 发生超市丢包，慢启动阈值设置为当前cwnd/2，cwnd至为1个MSS重新进行慢启动
