

#### JVM运行时数据区

JVM运行时数据区，包括线程私有的程序计数器、虚拟机栈、本地方法栈，线程共享的方法区和堆，其中只有程序计数器不会发生OOM。线程私有的部分生命周期和线程相同，而线程共享的部分生命周期于JVM相同。

- 程序计数器：记录下一条指令的地址，执行native方法时为空
- 虚拟机栈：存放栈帧，栈帧中存放局部变量表、操作数栈、动态连接、方法返回地址等。
- 本地方法栈：为native方法服务
- 方法区：存储常量、静态变量、类信息、即时编译后的机器码、运行时常量池等，Java8后实现由永久代变为元空间
- 堆：创建的对象和产生的数据被存放在堆中，被线程共享，根据分代收集理论，对被划分为新生代、老年代，新生代又分为Eden、from和to区。

#### 垃圾回收算法

利用引用计数和可达性分析判断对象是否可以被回收，可达性分析通过根搜索算法，以GC Roots作为起点向下搜索，可作为GC Roots的一般为栈中的引用、方法区的静态引用和常量引用、本地方法栈的引用。

- 复制算法：将内存划分为两块，只使用其中一块，标记存活对象并复制到另一块中，再直接清理掉其余的空间。如果系统中由大=大量存活对象，来回复制会影响运行效率，所以适合用于对象朝生夕灭的新生代。
- 标记清除算法：在标记阶段标记需要回收的对象，清除阶段清除可回收的对象并释放其占用的内存。如果不进行整理会引起内存碎片化问题，影响大对象的分配。
- 标记整理算法：标记完成后，将存活对象移动闹内存一端，再清除其余空间。 

#### 分代收集

新生代使用复制算法，老年代使用标记清除或标记整理算法。

新生代复制算法，新生代默认占堆内存的1/3，分为Eden、From和To区，比例为8:1:1。由于会频繁创建对象，新生代会经常发生Minor GC。新创建的对象首先会放在Eden区（特殊情况大对象会直接分配到老年代），发生Minor GC时，会将Eden区和From区的存货对象复制到To区，如果此时有对象到达晋升老年代的标准（默认15），将会把它复制到老年代，如果此时To区空间不够也会直接复制到老年代，然后清空Eden区和From区，并将From和To的引用互换。

#### 垃圾收集器

- 新生代
  - Serial：单线程复制算法
  - ParNew：多线程的复制算法，采用多线程工作，除此之外和Serial一样
  - Parallel Scavenge：多线程复制算法，吞吐量优先，可以更高效的利用CPU，控制最大垃圾收集停顿时间、吞吐量。
- 老年代
  - Serial Old：单线程标记整理算法
  - Parallel Old：多线程的垃圾整理算法，对应于Parallel Scavenge，设计上优先考虑吞吐量、其次是停顿时间
  - CMS：并发标记清除
- G1：使用标记整理算法，分区收集，利用优先队列，在回收垃圾时优先收集垃圾最多的区域，保证在有限时间内获得最高的垃圾手机效率，精确控制停顿时间。CMS包括初始标记、并发标记、重新标记、并发清除，其中初始标记和重新标记需要STW，而工作量较大的部分可以与用户线程并发执行。由于CMS是标记清除算法，会导致内存碎片，当发生Concurrent Mode Failure时，会使用Serial Old算法进行标记整理。

#### 类加载过程

JVM的类加载分为：加载、验证、准备、解析、初始化、使用、卸载。

- 加载：读取Class文件，读取到运行时方法区，在堆中创建Class对象。
- 验证：确保Class文件符合规范
- 准备：为类变量分配空间并赋初值（null、0..），final修饰的变量在编译期生成常量
- 解析：将常量池的符号引用替换为直接引用，符号引用是JVM用于表示变量类型的缩写
- 初始化：执行类构造器的<clint>方法，为静态变量赋值和执行静态代码块

仅在以下情况会发生类的初始化

- new创建类的实例
- 访问类的静态变量，或为静态变量赋值，但不包过final修饰的静态变量
- 调用类的静态方法
- 使用反射对类进行调用时
- 初始化某个类的子类
- Main方法入口的类

以下情况不会触发初始化

- 常量，在编译期放入该类的常量池
- 子类引用父类的静态字段，不会触发子类的初始化
- 定义对象数组，不会触发该类的初始化
- 使用类名获得Class对象
- Class.forName加载类时，通过initialized参数指定是否需要初始化
- ClassLoader.loadClass加载类

#### 类加载器

JVM提供三种类加载器

- Bootstrap ClassLoader：引导类加载器，加载JAVA_HOME/lib目录中的类
- ExtClassLoader：扩展类加载器，加载JAVA_HOME/lib/ext目录中的类
- AppClassLoader，应用类加载器，加载用户路径classpath下的类

双亲委派机制，一个类加载器在收到类加载请求时不会首先自己去加载，而是委托给父类加载器去加载（父类加载器存在于ClassLoader的字段中），依次递归请求至顶层的引导类加载器，如果此时父类加载器可以加载就成功返回，否则才会回溯到子类加载器去加载。

双亲委派机制是为了保障类的唯一性和安全性，避免重复的类被加载，避免核心的类被外部同名类覆盖。
